name: CI/CD Pipeline - Deploy Todo App to AWS

on:
  push:
    branches:
      - main
      - develop
  pull_request:
    branches:
      - main

env:
  AWS_REGION: us-east-1
  STACK_NAME: todo-app-stack

jobs:
  # ==================== JOB 1: Tests ====================
  test:
    name: Run Tests
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json

      - name: Install backend dependencies
        working-directory: ./backend
        run: npm ci

      - name: Run backend tests
        working-directory: ./backend
        run: npm test || echo "No tests found"
        continue-on-error: true

      - name: Lint backend code
        working-directory: ./backend
        run: npm run lint || echo "No lint configured"
        continue-on-error: true

  # ==================== JOB 2: Build ====================
  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: test

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Build backend
        working-directory: ./backend
        run: |
          npm ci
          echo "Backend built successfully"

      - name: Build frontend
        working-directory: ./frontend
        run: |
          npm ci
          npm run build

      - name: Archive artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: |
            backend/
            frontend/build/
          retention-days: 1

  # ==================== JOB 3: Infrastructure ====================
  deploy-infrastructure:
    name: Deploy AWS Infrastructure
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    outputs:
      webserver-ip: ${{ steps.get-outputs.outputs.webserver-ip }}
      database-ip: ${{ steps.get-outputs.outputs.database-ip }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify Key Pair exists
        run: |
          echo "üîç V√©rification de la Key Pair EC2..."
          KEY_PAIR_NAME="${{ secrets.EC2_KEY_PAIR_NAME }}"
          
          if aws ec2 describe-key-pairs --key-names "$KEY_PAIR_NAME" --region ${{ env.AWS_REGION }} &> /dev/null; then
            echo "‚úÖ Key Pair '$KEY_PAIR_NAME' existe dans la r√©gion ${{ env.AWS_REGION }}"
            
            # Afficher le fingerprint
            FINGERPRINT=$(aws ec2 describe-key-pairs \
              --key-names "$KEY_PAIR_NAME" \
              --region ${{ env.AWS_REGION }} \
              --query "KeyPairs[0].KeyFingerprint" \
              --output text)
            echo "üìã Fingerprint: $FINGERPRINT"
          else
            echo "‚ùå ERREUR: Key Pair '$KEY_PAIR_NAME' n'existe pas dans la r√©gion ${{ env.AWS_REGION }}"
            echo ""
            echo "üîß Solutions:"
            echo "  1. Cr√©ez la Key Pair dans la console AWS:"
            echo "     https://${{ env.AWS_REGION }}.console.aws.amazon.com/ec2/home?region=${{ env.AWS_REGION }}#KeyPairs:"
            echo ""
            echo "  2. Ou cr√©ez-la via AWS CLI:"
            echo "     aws ec2 create-key-pair --key-name $KEY_PAIR_NAME --region ${{ env.AWS_REGION }}"
            echo ""
            echo "  3. Assurez-vous que le secret EC2_KEY_PAIR_NAME dans GitHub correspond au nom exact"
            exit 1
          fi

      - name: Validate CloudFormation template
        run: |
          aws cloudformation validate-template \
            --template-body file://infrastructure/infrastructure.yml

      - name: Deploy CloudFormation stack
        run: |
          echo "üöÄ D√©ploiement de la stack CloudFormation..."
          echo "Stack: ${{ env.STACK_NAME }}"
          echo "R√©gion: ${{ env.AWS_REGION }}"
          echo "Key Pair: ${{ secrets.EC2_KEY_PAIR_NAME }}"
          echo ""
          
          # V√©rifier que la Key Pair existe AVANT le d√©ploiement
          echo "üîç V√©rification finale de la Key Pair..."
          KEY_PAIR_NAME="${{ secrets.EC2_KEY_PAIR_NAME }}"
          
          # Afficher la longueur et les caract√®res (pour d√©boguer)
          echo "Longueur du nom: ${#KEY_PAIR_NAME}"
          echo "Nom (avec guillemets pour voir les espaces): '$KEY_PAIR_NAME'"
          echo ""
          
          # Lister toutes les Key Pairs disponibles
          echo "üìã Key Pairs disponibles dans ${{ env.AWS_REGION }}:"
          aws ec2 describe-key-pairs --region ${{ env.AWS_REGION }} --query "KeyPairs[*].KeyName" --output table
          echo ""
          
          # V√©rifier si la Key Pair existe
          if ! aws ec2 describe-key-pairs --key-names "$KEY_PAIR_NAME" --region ${{ env.AWS_REGION }} &> /dev/null; then
            echo "‚ùå ERREUR CRITIQUE: Key Pair '$KEY_PAIR_NAME' n'existe pas dans ${{ env.AWS_REGION }}"
            echo ""
            echo "üí° Solution: Utilisez une des Key Pairs list√©es ci-dessus"
            echo "   Modifiez le secret EC2_KEY_PAIR_NAME dans GitHub avec exactement le nom de la Key Pair"
            exit 1
          fi
          
          # Afficher les d√©tails de la Key Pair trouv√©e
          KEY_INFO=$(aws ec2 describe-key-pairs --key-names "$KEY_PAIR_NAME" --region ${{ env.AWS_REGION }} --query "KeyPairs[0]" --output json)
          echo "‚úÖ Key Pair v√©rifi√©e: $KEY_PAIR_NAME"
          echo "   Fingerprint: $(echo "$KEY_INFO" | jq -r '.KeyFingerprint')"
          echo "   Type: $(echo "$KEY_INFO" | jq -r '.KeyType')"
          echo ""
          
          # Tenter le d√©ploiement avec create-stack d'abord (pour voir l'erreur compl√®te)
          echo "üîç V√©rification si la stack existe..."
          STACK_EXISTS=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query "Stacks[0].StackStatus" \
            --output text 2>/dev/null || echo "NOT_FOUND")
          
          if [ "$STACK_EXISTS" == "NOT_FOUND" ]; then
            echo "üì¶ Cr√©ation de la stack (premi√®re fois)..."
            # Utiliser create-stack pour voir l'erreur compl√®te
            if ! aws cloudformation create-stack \
              --stack-name ${{ env.STACK_NAME }} \
              --template-body file://infrastructure/infrastructure.yml \
              --parameters \
                ParameterKey=EnvironmentName,ParameterValue=prod \
                ParameterKey=KeyPairName,ParameterValue="$KEY_PAIR_NAME" \
                ParameterKey=AlertEmail,ParameterValue=${{ secrets.ALERT_EMAIL }} \
              --capabilities CAPABILITY_IAM \
              --region ${{ env.AWS_REGION }}; then
              
              echo ""
              echo "‚ùå √âchec de la cr√©ation de la stack"
              echo "R√©cup√©ration des d√©tails de l'erreur..."
              # Attendre un peu pour que l'erreur soit enregistr√©e
              sleep 5
              
              # Obtenir les √©v√©nements r√©cents
              aws cloudformation describe-stack-events \
                --stack-name ${{ env.STACK_NAME }} \
                --region ${{ env.AWS_REGION }} \
                --max-items 5 \
                --query "StackEvents[*].[Timestamp,ResourceStatus,LogicalResourceId,ResourceStatusReason]" \
                --output table 2>/dev/null || echo "Stack pas encore cr√©√©e"
              
              exit 1
            fi
            echo "‚úÖ Stack en cours de cr√©ation..."
            aws cloudformation wait stack-create-complete \
              --stack-name ${{ env.STACK_NAME }} \
              --region ${{ env.AWS_REGION }}
            echo "‚úÖ Stack cr√©√©e avec succ√®s"
          else
            echo "üîÑ Mise √† jour de la stack existante..."
            # Utiliser deploy pour la mise √† jour
            if ! aws cloudformation deploy \
              --template-file infrastructure/infrastructure.yml \
              --stack-name ${{ env.STACK_NAME }} \
              --parameter-overrides \
                EnvironmentName=prod \
                KeyPairName="$KEY_PAIR_NAME" \
                AlertEmail=${{ secrets.ALERT_EMAIL }} \
              --capabilities CAPABILITY_IAM \
              --no-fail-on-empty-changeset \
              --region ${{ env.AWS_REGION }}; then
              
              echo ""
              echo "‚ùå √âchec de la mise √† jour de la stack"
              echo "R√©cup√©ration des d√©tails..."
              sleep 3
              
              echo ""
              echo "‚ùå √âchec du d√©ploiement CloudFormation"
              echo "======================================"
              echo ""
              
              # Afficher les √©v√©nements r√©cents
              echo "üìã √âv√©nements r√©cents de la stack:"
              aws cloudformation describe-stack-events \
                --stack-name ${{ env.STACK_NAME }} \
                --region ${{ env.AWS_REGION }} \
                --max-items 5 \
                --query "StackEvents[*].[Timestamp,ResourceStatus,LogicalResourceId,ResourceStatusReason]" \
                --output table || echo "Impossible de r√©cup√©rer les √©v√©nements"
              
              echo ""
              echo "üîç Recherche de changementsets en √©chec..."
              CHANGESET_ID=$(aws cloudformation list-change-sets \
                --stack-name ${{ env.STACK_NAME }} \
                --region ${{ env.AWS_REGION }} \
                --query "Summaries[?Status=='FAILED'] | [0].ChangeSetId" \
                --output text 2>/dev/null || echo "")
              
              if [ -n "$CHANGESET_ID" ] && [ "$CHANGESET_ID" != "None" ]; then
                echo "üìã Raison de l'√©chec du changeset:"
                aws cloudformation describe-change-set \
                  --change-set-name "$CHANGESET_ID" \
                  --stack-name ${{ env.STACK_NAME }} \
                  --region ${{ env.AWS_REGION }} \
                  --query "StatusReason" \
                  --output text || echo "Impossible de r√©cup√©rer la raison"
              fi
              
              echo ""
              echo "üí° V√©rifications √† faire:"
              echo "  1. V√©rifiez que la Key Pair '$KEY_PAIR_NAME' existe dans ${{ env.AWS_REGION }}"
              echo "  2. V√©rifiez les permissions IAM de votre utilisateur AWS"
              echo "  3. V√©rifiez que l'AMI ID dans le template existe dans ${{ env.AWS_REGION }}"
              echo ""
              echo "üìã Key Pairs disponibles dans ${{ env.AWS_REGION }}:"
              aws ec2 describe-key-pairs --region ${{ env.AWS_REGION }} --query "KeyPairs[*].KeyName" --output table || echo "Impossible de lister les Key Pairs"
              
              exit 1
            fi
            echo "‚úÖ Stack mise √† jour avec succ√®s"
          fi
          
          echo "‚úÖ Stack d√©ploy√©e avec succ√®s"

      - name: Get stack outputs
        id: get-outputs
        run: |
          WEBSERVER_IP=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='WebServerPublicIP'].OutputValue" \
            --output text)
          
          DATABASE_IP=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='DatabasePrivateIP'].OutputValue" \
            --output text)
          
          echo "webserver-ip=$WEBSERVER_IP" >> $GITHUB_OUTPUT
          echo "database-ip=$DATABASE_IP" >> $GITHUB_OUTPUT
          
          echo "üåê WebServer IP: $WEBSERVER_IP"
          echo "üíæ Database IP: $DATABASE_IP"

  # ==================== JOB 4: Deploy Database ====================
  deploy-database:
    name: Deploy Database
    runs-on: ubuntu-latest
    needs: deploy-infrastructure
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ needs.deploy-infrastructure.outputs.webserver-ip }} >> ~/.ssh/known_hosts

      - name: Get database IP from stack
        id: get-db-ip
        run: |
          DATABASE_IP=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='DatabasePrivateIP'].OutputValue" \
            --output text)
          echo "database-ip=$DATABASE_IP" >> $GITHUB_OUTPUT

      - name: Wait for instances to be ready
        run: |
          echo "‚è≥ Attente de la disponibilit√© des instances..."
          sleep 60

      - name: Deploy database initialization script
        run: |
          # Copier le script sur le WebServer
          scp -o StrictHostKeyChecking=no \
            -o ConnectTimeout=30 \
            -i ~/.ssh/id_rsa \
            database/init.sql \
            ec2-user@${{ needs.deploy-infrastructure.outputs.webserver-ip }}:/tmp/init.sql || exit 1
          
          # Copier le script sur la DB via le WebServer
          ssh -o StrictHostKeyChecking=no \
            -o ConnectTimeout=30 \
            -i ~/.ssh/id_rsa \
            ec2-user@${{ needs.deploy-infrastructure.outputs.webserver-ip }} \
            "scp -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa /tmp/init.sql ec2-user@${{ steps.get-db-ip.outputs.database-ip }}:/tmp/init.sql" || exit 1
          
          # Ex√©cuter le script sur la DB
          ssh -o StrictHostKeyChecking=no \
            -o ConnectTimeout=30 \
            -i ~/.ssh/id_rsa \
            ec2-user@${{ needs.deploy-infrastructure.outputs.webserver-ip }} \
            "ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa ec2-user@${{ steps.get-db-ip.outputs.database-ip }} \
            'sudo -u postgres psql -f /tmp/init.sql || echo \"Database may already be initialized\"'" || echo "Database setup completed or already exists"

  # ==================== JOB 5: Deploy Application ====================
  deploy-application:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, deploy-database]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ needs.deploy-infrastructure.outputs.webserver-ip }} >> ~/.ssh/known_hosts

      - name: Get database IP
        id: get-db-ip
        run: |
          DATABASE_IP=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='DatabasePrivateIP'].OutputValue" \
            --output text)
          echo "database-ip=$DATABASE_IP" >> $GITHUB_OUTPUT

      - name: Deploy backend to EC2
        run: |
          # Cr√©er le fichier .env
          echo "PORT=3000" > backend/.env
          echo "NODE_ENV=production" >> backend/.env
          echo "DB_HOST=${{ steps.get-db-ip.outputs.database-ip }}" >> backend/.env
          echo "DB_PORT=5432" >> backend/.env
          echo "DB_NAME=tododb" >> backend/.env
          echo "DB_USER=todouser" >> backend/.env
          echo "DB_PASSWORD=${{ secrets.DB_PASSWORD }}" >> backend/.env
          
          # Cr√©er une archive
          tar -czf backend.tar.gz -C backend .
          
          # Copier l'archive sur le serveur
          scp -o StrictHostKeyChecking=no \
            -o ConnectTimeout=30 \
            -i ~/.ssh/id_rsa \
            backend.tar.gz \
            ec2-user@${{ needs.deploy-infrastructure.outputs.webserver-ip }}:/tmp/
          
          # Extraire et d√©ployer
          ssh -o StrictHostKeyChecking=no \
            -o ConnectTimeout=30 \
            -i ~/.ssh/id_rsa \
            ec2-user@${{ needs.deploy-infrastructure.outputs.webserver-ip }} << 'EOF'
            mkdir -p /home/ec2-user/app
            cd /home/ec2-user/app
            tar -xzf /tmp/backend.tar.gz
            rm /tmp/backend.tar.gz
            
            # Installer Node.js si n√©cessaire
            if ! command -v node &> /dev/null; then
              curl -fsSL https://rpm.nodesource.com/setup_16.x | sudo bash -
              sudo yum install -y nodejs
            fi
            
            # Installer les d√©pendances
            npm install --production --no-audit
            
            # Arr√™ter l'ancienne instance
            pkill -f "node server.js" || true
            sleep 2
            
            # D√©marrer la nouvelle instance
            nohup node server.js > /home/ec2-user/app/app.log 2>&1 &
            sleep 5
            
            # V√©rifier que le processus tourne
            if pgrep -f "node server.js" > /dev/null; then
              echo "‚úÖ Application d√©ploy√©e avec succ√®s"
            else
              echo "‚ùå Erreur: L'application n'a pas d√©marr√©"
              cat /home/ec2-user/app/app.log
              exit 1
            fi
          EOF

      - name: Deploy frontend (optional)
        run: |
          echo "Frontend build ready in frontend/build/"
          # Optionnel: d√©ployer sur S3 ou servir via nginx

  # ==================== JOB 6: Health Check ====================
  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    needs: deploy-application
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
      - name: Wait for application to start
        run: |
          echo "‚è≥ Attente du d√©marrage de l'application..."
          sleep 45
          
          # Attendre jusqu'√† 2 minutes que l'API r√©ponde
          WEBSERVER_IP="${{ needs.deploy-infrastructure.outputs.webserver-ip }}"
          MAX_ATTEMPTS=24
          ATTEMPT=0
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            if curl -s -f -m 5 http://$WEBSERVER_IP:3000/health > /dev/null 2>&1; then
              echo "‚úÖ API est disponible"
              break
            fi
            ATTEMPT=$((ATTEMPT + 1))
            echo "‚è≥ Tentative $ATTEMPT/$MAX_ATTEMPTS..."
            sleep 5
          done
          
          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "‚ùå L'API n'est pas disponible apr√®s $MAX_ATTEMPTS tentatives"
            exit 1
          fi

      - name: Check API health
        run: |
          WEBSERVER_IP="${{ needs.deploy-infrastructure.outputs.webserver-ip }}"
          
          echo "üîç V√©rification de l'API..."
          
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" -m 10 http://$WEBSERVER_IP:3000/health)
          
          if [ "$RESPONSE" -eq 200 ]; then
            echo "‚úÖ API est en bonne sant√© (HTTP $RESPONSE)"
            curl -s -m 10 http://$WEBSERVER_IP:3000/health | jq . || echo "Health check response received"
          else
            echo "‚ùå API ne r√©pond pas correctement (HTTP $RESPONSE)"
            exit 1
          fi

      - name: Test API endpoints
        run: |
          WEBSERVER_IP="${{ needs.deploy-infrastructure.outputs.webserver-ip }}"
          
          echo "üìã Test GET /api/todos..."
          curl -s -m 10 http://$WEBSERVER_IP:3000/api/todos | jq . || echo "Todos endpoint test completed"
          
          echo "üìä Test GET /api/todos/stats..."
          curl -s -m 10 http://$WEBSERVER_IP:3000/api/todos/stats || echo "Stats endpoint test completed"

  # ==================== JOB 7: Notification ====================
  notify:
    name: Send Notification
    runs-on: ubuntu-latest
    needs: health-check
    if: always()

    steps:
      - name: Send success notification
        if: needs.health-check.result == 'success'
        run: |
          echo "‚úÖ D√©ploiement r√©ussi!"
          echo "üåê Application accessible sur: http://${{ needs.deploy-infrastructure.outputs.webserver-ip }}:3000"

      - name: Send failure notification
        if: needs.health-check.result == 'failure'
        run: |
          echo "‚ùå D√©ploiement √©chou√©!"
          exit 1