name: CI/CD Pipeline - Deploy Todo App to AWS

on:
  push:
    branches:
      - main
      - develop
  pull_request:
    branches:
      - main

env:
  AWS_REGION: us-east-1
  STACK_NAME: todo-app-stack

jobs:
  # ==================== JOB 1: Tests ====================
  test:
    name: Run Tests
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json

      - name: Install backend dependencies
        working-directory: ./backend
        run: npm ci

      - name: Run backend tests
        working-directory: ./backend
        run: npm test || echo "No tests found"
        continue-on-error: true

      - name: Lint backend code
        working-directory: ./backend
        run: npm run lint || echo "No lint configured"
        continue-on-error: true

  # ==================== JOB 2: Build ====================
  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: test

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Build backend
        working-directory: ./backend
        run: |
          npm ci
          echo "Backend built successfully"

      - name: Build frontend
        working-directory: ./frontend
        run: |
          npm ci
          # Configurer l'URL de l'API pour la production
          # L'IP sera remplac√©e lors du d√©ploiement
          echo "REACT_APP_API_URL=http://PLACEHOLDER_WEBSERVER_IP:3000" > .env.production
          npm run build
          # Cr√©er un fichier de configuration pour override dynamique
          cat > build/config.js << 'CONFIG_EOF'
          // Configuration de l'API - sera mise √† jour lors du d√©ploiement
          window.REACT_APP_API_URL = window.REACT_APP_API_URL || 'http://PLACEHOLDER_WEBSERVER_IP:3000';
          CONFIG_EOF
          # Injecter le script dans index.html
          sed -i 's|</head>|<script src="/config.js"></script></head>|' build/index.html

      - name: Archive artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: |
            backend/
            frontend/build/
          retention-days: 1

  # ==================== JOB 3: Infrastructure ====================
  deploy-infrastructure:
    name: Deploy AWS Infrastructure
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    outputs:
      webserver-ip: ${{ steps.get-outputs.outputs.webserver-ip }}
      database-ip: ${{ steps.get-outputs.outputs.database-ip }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify Key Pair exists
        run: |
          echo "üîç V√©rification de la Key Pair EC2..."
          KEY_PAIR_NAME="${{ secrets.EC2_KEY_PAIR_NAME }}"
          
          if aws ec2 describe-key-pairs --key-names "$KEY_PAIR_NAME" --region ${{ env.AWS_REGION }} &> /dev/null; then
            echo "‚úÖ Key Pair '$KEY_PAIR_NAME' existe dans la r√©gion ${{ env.AWS_REGION }}"
            
            # Afficher le fingerprint
            FINGERPRINT=$(aws ec2 describe-key-pairs \
              --key-names "$KEY_PAIR_NAME" \
              --region ${{ env.AWS_REGION }} \
              --query "KeyPairs[0].KeyFingerprint" \
              --output text)
            echo "üìã Fingerprint: $FINGERPRINT"
          else
            echo "‚ùå ERREUR: Key Pair '$KEY_PAIR_NAME' n'existe pas dans la r√©gion ${{ env.AWS_REGION }}"
            echo ""
            echo "üîß Solutions:"
            echo "  1. Cr√©ez la Key Pair dans la console AWS:"
            echo "     https://${{ env.AWS_REGION }}.console.aws.amazon.com/ec2/home?region=${{ env.AWS_REGION }}#KeyPairs:"
            echo ""
            echo "  2. Ou cr√©ez-la via AWS CLI:"
            echo "     aws ec2 create-key-pair --key-name $KEY_PAIR_NAME --region ${{ env.AWS_REGION }}"
            echo ""
            echo "  3. Assurez-vous que le secret EC2_KEY_PAIR_NAME dans GitHub correspond au nom exact"
            exit 1
          fi

      - name: Validate CloudFormation template
        run: |
          aws cloudformation validate-template \
            --template-body file://infrastructure/infrastructure.yml

      - name: Deploy CloudFormation stack
        run: |
          echo "üöÄ D√©ploiement de la stack CloudFormation..."
          echo "Stack: ${{ env.STACK_NAME }}"
          echo "R√©gion: ${{ env.AWS_REGION }}"
          echo "Key Pair: ${{ secrets.EC2_KEY_PAIR_NAME }}"
          echo ""
          
          # V√©rifier que la Key Pair existe AVANT le d√©ploiement
          echo "üîç V√©rification finale de la Key Pair..."
          KEY_PAIR_NAME="${{ secrets.EC2_KEY_PAIR_NAME }}"
          
          # Afficher la longueur et les caract√®res (pour d√©boguer)
          echo "Longueur du nom: ${#KEY_PAIR_NAME}"
          echo "Nom (avec guillemets pour voir les espaces): '$KEY_PAIR_NAME'"
          echo ""
          
          # Lister toutes les Key Pairs disponibles
          echo "üìã Key Pairs disponibles dans ${{ env.AWS_REGION }}:"
          aws ec2 describe-key-pairs --region ${{ env.AWS_REGION }} --query "KeyPairs[*].KeyName" --output table
          echo ""
          
          # V√©rifier si la Key Pair existe
          if ! aws ec2 describe-key-pairs --key-names "$KEY_PAIR_NAME" --region ${{ env.AWS_REGION }} &> /dev/null; then
            echo "‚ùå ERREUR CRITIQUE: Key Pair '$KEY_PAIR_NAME' n'existe pas dans ${{ env.AWS_REGION }}"
            echo ""
            echo "üí° Solution: Utilisez une des Key Pairs list√©es ci-dessus"
            echo "   Modifiez le secret EC2_KEY_PAIR_NAME dans GitHub avec exactement le nom de la Key Pair"
            exit 1
          fi
          
          # Afficher les d√©tails de la Key Pair trouv√©e
          KEY_INFO=$(aws ec2 describe-key-pairs --key-names "$KEY_PAIR_NAME" --region ${{ env.AWS_REGION }} --query "KeyPairs[0]" --output json)
          echo "‚úÖ Key Pair v√©rifi√©e: $KEY_PAIR_NAME"
          echo "   Fingerprint: $(echo "$KEY_INFO" | jq -r '.KeyFingerprint')"
          echo "   Type: $(echo "$KEY_INFO" | jq -r '.KeyType')"
          echo ""
          
          # Tenter le d√©ploiement avec create-stack d'abord (pour voir l'erreur compl√®te)
          echo "üîç V√©rification si la stack existe..."
          STACK_STATUS=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query "Stacks[0].StackStatus" \
            --output text 2>/dev/null || echo "NOT_FOUND")
          
          # Si la stack est en cours de cr√©ation ou de mise √† jour, attendre
          if [ "$STACK_STATUS" == "CREATE_IN_PROGRESS" ] || [ "$STACK_STATUS" == "UPDATE_IN_PROGRESS" ] || [ "$STACK_STATUS" == "UPDATE_ROLLBACK_IN_PROGRESS" ]; then
            echo "‚è≥ Stack en cours de traitement ($STACK_STATUS), attente de la fin..."
            if [ "$STACK_STATUS" == "CREATE_IN_PROGRESS" ]; then
              echo "‚è≥ Attente de la fin de la cr√©ation (cela peut prendre 10-15 minutes)..."
              aws cloudformation wait stack-create-complete \
                --stack-name ${{ env.STACK_NAME }} \
                --region ${{ env.AWS_REGION }} || true
            elif [ "$STACK_STATUS" == "UPDATE_IN_PROGRESS" ]; then
              echo "‚è≥ Attente de la fin de la mise √† jour..."
              aws cloudformation wait stack-update-complete \
                --stack-name ${{ env.STACK_NAME }} \
                --region ${{ env.AWS_REGION }} || true
            fi
            # Re-v√©rifier le statut apr√®s l'attente
            STACK_STATUS=$(aws cloudformation describe-stacks \
              --stack-name ${{ env.STACK_NAME }} \
              --region ${{ env.AWS_REGION }} \
              --query "Stacks[0].StackStatus" \
              --output text 2>/dev/null || echo "NOT_FOUND")
            echo "üìä Statut apr√®s attente: $STACK_STATUS"
            echo ""
          fi
          
          if [ "$STACK_STATUS" == "NOT_FOUND" ]; then
            echo "üì¶ Cr√©ation de la stack (premi√®re fois)..."
            # Utiliser create-stack pour voir l'erreur compl√®te
            if ! aws cloudformation create-stack \
              --stack-name ${{ env.STACK_NAME }} \
              --template-body file://infrastructure/infrastructure.yml \
              --parameters \
                ParameterKey=EnvironmentName,ParameterValue=prod \
                ParameterKey=KeyPairName,ParameterValue="$KEY_PAIR_NAME" \
                ParameterKey=AlertEmail,ParameterValue=${{ secrets.ALERT_EMAIL }} \
              --capabilities CAPABILITY_IAM \
              --region ${{ env.AWS_REGION }}; then
              
              echo ""
              echo "‚ùå √âchec de la cr√©ation de la stack"
              echo "R√©cup√©ration des d√©tails de l'erreur..."
              # Attendre un peu pour que l'erreur soit enregistr√©e
              sleep 5
              
              # Obtenir les √©v√©nements r√©cents
              aws cloudformation describe-stack-events \
                --stack-name ${{ env.STACK_NAME }} \
                --region ${{ env.AWS_REGION }} \
                --max-items 5 \
                --query "StackEvents[*].[Timestamp,ResourceStatus,LogicalResourceId,ResourceStatusReason]" \
                --output table 2>/dev/null || echo "Stack pas encore cr√©√©e"
              
              exit 1
            fi
            echo "‚úÖ Stack en cours de cr√©ation..."
            echo "‚è≥ Attente de la cr√©ation (cela peut prendre 10-15 minutes)..."
            
            # Attendre avec gestion d'erreur
            if ! aws cloudformation wait stack-create-complete \
              --stack-name ${{ env.STACK_NAME }} \
              --region ${{ env.AWS_REGION }}; then
              
              echo ""
              echo "‚ùå √âchec de la cr√©ation de la stack"
              echo "===================================="
              echo ""
              
              # Obtenir l'√©tat final
              FINAL_STATUS=$(aws cloudformation describe-stacks \
                --stack-name ${{ env.STACK_NAME }} \
                --region ${{ env.AWS_REGION }} \
                --query "Stacks[0].StackStatus" \
                --output text 2>/dev/null || echo "UNKNOWN")
              
              echo "√âtat final: $FINAL_STATUS"
              echo ""
              
              # Afficher les √©v√©nements d'erreur
              echo "üìã √âv√©nements d'erreur de la stack (CREATE_FAILED):"
              FAILED_EVENTS=$(aws cloudformation describe-stack-events \
                --stack-name ${{ env.STACK_NAME }} \
                --region ${{ env.AWS_REGION }} \
                --max-items 50 \
                --query "StackEvents[?ResourceStatus=='CREATE_FAILED'].[Timestamp,LogicalResourceId,ResourceStatusReason]" \
                --output table 2>/dev/null || echo "")
              
              if [ -n "$FAILED_EVENTS" ]; then
                echo "$FAILED_EVENTS"
              else
                echo "Aucun √©v√©nement CREATE_FAILED trouv√©"
                echo ""
                echo "Recherche de tous les √©v√©nements avec 'failed' ou 'error'..."
                aws cloudformation describe-stack-events \
                  --stack-name ${{ env.STACK_NAME }} \
                  --region ${{ env.AWS_REGION }} \
                  --max-items 50 \
                  --query "StackEvents[?contains(ResourceStatusReason, 'failed') || contains(ResourceStatusReason, 'Failed') || contains(ResourceStatusReason, 'error') || contains(ResourceStatusReason, 'Error') || contains(ResourceStatusReason, 'already exists')].[Timestamp,LogicalResourceId,ResourceStatus,ResourceStatusReason]" \
                  --output table 2>/dev/null || echo "Impossible de r√©cup√©rer les √©v√©nements"
              fi
              
              echo ""
              echo "üìã Tous les √©v√©nements r√©cents:"
              aws cloudformation describe-stack-events \
                --stack-name ${{ env.STACK_NAME }} \
                --region ${{ env.AWS_REGION }} \
                --max-items 15 \
                --query "StackEvents[*].[Timestamp,ResourceStatus,LogicalResourceId,ResourceStatusReason]" \
                --output table || echo "Impossible de r√©cup√©rer les √©v√©nements"
              
              exit 1
            fi
            
            echo "‚úÖ Stack cr√©√©e avec succ√®s"
          elif [ "$STACK_STATUS" != "NOT_FOUND" ]; then
            echo "üîÑ Mise √† jour de la stack existante..."
            echo "üìä Statut actuel: $STACK_STATUS"
            # Utiliser deploy pour la mise √† jour
            if ! aws cloudformation deploy \
              --template-file infrastructure/infrastructure.yml \
            --stack-name ${{ env.STACK_NAME }} \
            --parameter-overrides \
              EnvironmentName=prod \
                KeyPairName="$KEY_PAIR_NAME" \
              AlertEmail=${{ secrets.ALERT_EMAIL }} \
            --capabilities CAPABILITY_IAM \
              --no-fail-on-empty-changeset \
              --region ${{ env.AWS_REGION }}; then
              
              echo ""
              echo "‚ùå √âchec de la mise √† jour de la stack"
              echo "R√©cup√©ration des d√©tails..."
              sleep 3
              
              echo ""
              echo "‚ùå √âchec du d√©ploiement CloudFormation"
              echo "======================================"
              echo ""
              
              # Afficher les √©v√©nements r√©cents
              echo "üìã √âv√©nements r√©cents de la stack:"
              aws cloudformation describe-stack-events \
                --stack-name ${{ env.STACK_NAME }} \
                --region ${{ env.AWS_REGION }} \
                --max-items 5 \
                --query "StackEvents[*].[Timestamp,ResourceStatus,LogicalResourceId,ResourceStatusReason]" \
                --output table || echo "Impossible de r√©cup√©rer les √©v√©nements"
              
              echo ""
              echo "üîç Recherche de changementsets en √©chec..."
              CHANGESET_ID=$(aws cloudformation list-change-sets \
                --stack-name ${{ env.STACK_NAME }} \
                --region ${{ env.AWS_REGION }} \
                --query "Summaries[?Status=='FAILED'] | [0].ChangeSetId" \
                --output text 2>/dev/null || echo "")
              
              if [ -n "$CHANGESET_ID" ] && [ "$CHANGESET_ID" != "None" ]; then
                echo "üìã Raison de l'√©chec du changeset:"
                aws cloudformation describe-change-set \
                  --change-set-name "$CHANGESET_ID" \
                  --stack-name ${{ env.STACK_NAME }} \
                  --region ${{ env.AWS_REGION }} \
                  --query "StatusReason" \
                  --output text || echo "Impossible de r√©cup√©rer la raison"
              fi
              
              echo ""
              echo "üí° V√©rifications √† faire:"
              echo "  1. V√©rifiez que la Key Pair '$KEY_PAIR_NAME' existe dans ${{ env.AWS_REGION }}"
              echo "  2. V√©rifiez les permissions IAM de votre utilisateur AWS"
              echo "  3. V√©rifiez que l'AMI ID dans le template existe dans ${{ env.AWS_REGION }}"
              echo ""
              echo "üìã Key Pairs disponibles dans ${{ env.AWS_REGION }}:"
              aws ec2 describe-key-pairs --region ${{ env.AWS_REGION }} --query "KeyPairs[*].KeyName" --output table || echo "Impossible de lister les Key Pairs"
              
              exit 1
            fi
            echo "‚úÖ Stack mise √† jour avec succ√®s"
          fi
          
          echo "‚úÖ Stack d√©ploy√©e avec succ√®s"

      - name: Get stack outputs
        id: get-outputs
        run: |
          WEBSERVER_IP=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='WebServerPublicIP'].OutputValue" \
            --output text)
          
          DATABASE_IP=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='DatabasePrivateIP'].OutputValue" \
            --output text)
          
          echo "webserver-ip=$WEBSERVER_IP" >> $GITHUB_OUTPUT
          echo "database-ip=$DATABASE_IP" >> $GITHUB_OUTPUT
          
          echo "üåê WebServer IP: $WEBSERVER_IP"
          echo "üíæ Database IP: $DATABASE_IP"

  # ==================== JOB 4: Deploy Database ====================
  deploy-database:
    name: Deploy Database
    runs-on: ubuntu-latest
    needs: deploy-infrastructure
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # V√©rifier que le secret existe
          if [ -z "${{ secrets.EC2_SSH_PRIVATE_KEY }}" ]; then
            echo "‚ùå ERREUR: Le secret EC2_SSH_PRIVATE_KEY n'est pas configur√© dans GitHub"
            echo ""
            echo "üìã Pour configurer le secret:"
            echo "  1. Allez dans: Settings ‚Üí Secrets and variables ‚Üí Actions"
            echo "  2. Cliquez sur 'New repository secret'"
            echo "  3. Nom: EC2_SSH_PRIVATE_KEY"
            echo "  4. Valeur: Collez le contenu complet de votre cl√© priv√©e (.pem)"
            echo ""
            echo "üí° Utilisez le script local pour obtenir le contenu exact:"
            echo "  ./scripts/check-ssh-key.sh ~/.ssh/todo-app-key.pem"
            exit 1
          fi
          
          # √âcrire la cl√© SSH
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # V√©rifier le format de base
          if ! grep -q "BEGIN.*PRIVATE KEY" ~/.ssh/id_rsa; then
            echo "‚ùå ERREUR: La cl√© SSH ne contient pas l'en-t√™te BEGIN"
            echo ""
            echo "La cl√© doit commencer par:"
            echo "  -----BEGIN RSA PRIVATE KEY-----"
            echo "  ou"
            echo "  -----BEGIN OPENSSH PRIVATE KEY-----"
            echo ""
            echo "V√©rifiez que vous avez copi√© TOUTE la cl√©, y compris les en-t√™tes"
            exit 1
          fi
          
          if ! grep -q "END.*PRIVATE KEY" ~/.ssh/id_rsa; then
            echo "‚ùå ERREUR: La cl√© SSH ne contient pas l'en-t√™te END"
            echo ""
            echo "üîç Diagnostic:"
            KEY_SIZE=$(wc -c < ~/.ssh/id_rsa)
            KEY_LINES=$(wc -l < ~/.ssh/id_rsa)
            LAST_LINE=$(tail -1 ~/.ssh/id_rsa)
            echo "  Taille: $KEY_SIZE octets"
            echo "  Lignes: $KEY_LINES"
            echo "  Derni√®re ligne: '$LAST_LINE'"
            echo ""
            if [ $KEY_SIZE -lt 1500 ]; then
              echo "  ‚ö†Ô∏è  La cl√© est TROP COURTE! Elle est probablement TRONQU√âE."
              echo "  Une cl√© RSA priv√©e compl√®te fait g√©n√©ralement 1700-1800 octets."
            fi
            echo ""
            echo "üìã Cause probable:"
            echo "  La cl√© n'a pas √©t√© copi√©e compl√®tement dans GitHub Secrets."
            echo "  La fin de la cl√© (ligne -----END RSA PRIVATE KEY-----) est manquante."
            echo ""
            echo "üí° Solution:"
            echo "  1. Ex√©cutez localement: ./scripts/generate-ssh-secret.sh ~/.ssh/todo-app-key.pem"
            echo "  2. Ouvrez le fichier github-ssh-secret.txt g√©n√©r√©"
            echo "  3. V√©rifiez que la derni√®re ligne est: -----END RSA PRIVATE KEY-----"
            echo "  4. S√©lectionnez TOUT le contenu (Cmd+A) et copiez-le"
            echo "  5. Dans GitHub: Settings ‚Üí Secrets ‚Üí Actions ‚Üí EC2_SSH_PRIVATE_KEY"
            echo "  6. Supprimez l'ancien contenu et collez TOUT le nouveau contenu"
            echo "  7. Assurez-vous que la derni√®re ligne visible est -----END RSA PRIVATE KEY-----"
            echo ""
            echo "üìñ Guide complet: CONFIGURER_SSH_SECRET.md"
            exit 1
          fi
          
          # Afficher des informations de debug (sans exposer la cl√© compl√®te)
          echo "üîç Informations de debug:"
          KEY_SIZE=$(wc -c < ~/.ssh/id_rsa)
          KEY_LINES=$(wc -l < ~/.ssh/id_rsa)
          echo "  Taille du fichier: $KEY_SIZE octets"
          echo "  Nombre de lignes: $KEY_LINES"
          echo "  Premi√®re ligne: $(head -1 ~/.ssh/id_rsa)"
          echo "  Derni√®re ligne: $(tail -1 ~/.ssh/id_rsa)"
          echo ""
          
          # V√©rifier que la cl√© est valide avec ssh-keygen
          echo "üîç Validation de la cl√© SSH..."
          VALIDATION_OUTPUT=$(ssh-keygen -l -f ~/.ssh/id_rsa 2>&1)
          VALIDATION_EXIT=$?
          
          if [ $VALIDATION_EXIT -ne 0 ]; then
            echo "‚ùå ERREUR: La cl√© SSH n'est pas valide"
            echo ""
            echo "D√©tails de l'erreur:"
            echo "$VALIDATION_OUTPUT"
            echo ""
            echo "üìã Analyse du probl√®me:"
            if [ $KEY_SIZE -lt 1000 ]; then
              echo "  ‚ö†Ô∏è  La cl√© semble trop courte ($KEY_SIZE octets). Elle est probablement tronqu√©e."
            fi
            if [ $KEY_LINES -lt 10 ]; then
              echo "  ‚ö†Ô∏è  La cl√© a trop peu de lignes ($KEY_LINES). Les retours √† la ligne sont peut-√™tre perdus."
            fi
            if ! grep -q "BEGIN.*PRIVATE KEY" ~/.ssh/id_rsa; then
              echo "  ‚ö†Ô∏è  L'en-t√™te BEGIN est manquant"
            fi
            if ! grep -q "END.*PRIVATE KEY" ~/.ssh/id_rsa; then
              echo "  ‚ö†Ô∏è  L'en-t√™te END est manquant"
            fi
            echo ""
            echo "üìã V√©rifications √† faire:"
            echo "  1. La cl√© est au format PEM complet"
            echo "  2. Les en-t√™tes BEGIN et END sont pr√©sents"
            echo "  3. Tous les retours √† la ligne sont pr√©serv√©s"
            echo "  4. Aucun espace suppl√©mentaire n'a √©t√© ajout√©"
            echo "  5. La cl√© compl√®te a √©t√© copi√©e (pas tronqu√©e)"
            echo ""
            echo "üí° Solution:"
            echo "  1. Ex√©cutez localement: ./scripts/generate-ssh-secret.sh ~/.ssh/todo-app-key.pem"
            echo "  2. Ouvrez le fichier github-ssh-secret.txt g√©n√©r√©"
            echo "  3. Copiez TOUT le contenu dans GitHub Secrets (Settings ‚Üí Secrets ‚Üí Actions)"
            echo ""
            echo "üìñ Guide complet: CONFIGURER_SSH_SECRET.md"
            exit 1
          fi
          
          # Afficher le fingerprint de la cl√© (pour debug)
          echo "‚úÖ Cl√© SSH valide:"
          ssh-keygen -l -f ~/.ssh/id_rsa
          
          # Ajouter l'IP du WebServer aux known_hosts
          ssh-keyscan -H ${{ needs.deploy-infrastructure.outputs.webserver-ip }} >> ~/.ssh/known_hosts 2>/dev/null || true
          chmod 644 ~/.ssh/known_hosts

      - name: Get database IP from stack
        id: get-db-ip
        run: |
          DATABASE_IP=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='DatabasePrivateIP'].OutputValue" \
            --output text)
          echo "database-ip=$DATABASE_IP" >> $GITHUB_OUTPUT

      - name: Wait for instances to be ready
        run: |
          echo "‚è≥ Attente de la disponibilit√© des instances..."
          WEBSERVER_IP="${{ needs.deploy-infrastructure.outputs.webserver-ip }}"
          MAX_ATTEMPTS=30
          ATTEMPT=0
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            echo "Tentative $((ATTEMPT + 1))/$MAX_ATTEMPTS: Test de connexion SSH..."
            if ssh -o StrictHostKeyChecking=no \
               -o ConnectTimeout=10 \
               -o BatchMode=yes \
               -i ~/.ssh/id_rsa \
               ec2-user@$WEBSERVER_IP \
               "echo 'SSH connection successful'" &> /dev/null; then
              echo "‚úÖ Instance WebServer est pr√™te!"
              break
            fi
            ATTEMPT=$((ATTEMPT + 1))
            if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
              echo "‚è≥ Instance pas encore pr√™te, attente de 10 secondes..."
              sleep 10
            fi
          done
          
          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "‚ùå ERREUR: Impossible de se connecter au WebServer apr√®s $MAX_ATTEMPTS tentatives"
            echo "V√©rifiez que:"
            echo "  1. L'instance est en cours d'ex√©cution"
            echo "  2. Le Security Group autorise les connexions SSH depuis GitHub Actions"
            echo "  3. La cl√© SSH est correctement configur√©e"
            exit 1
          fi

      - name: Deploy database initialization script
        run: |
          WEBSERVER_IP="${{ needs.deploy-infrastructure.outputs.webserver-ip }}"
          DATABASE_IP="${{ steps.get-db-ip.outputs.database-ip }}"
          
          echo "üì¶ D√©ploiement du script d'initialisation de la base de donn√©es..."
          echo "WebServer IP: $WEBSERVER_IP"
          echo "Database IP: $DATABASE_IP"
          
          # Copier le script sur le WebServer
          echo "1Ô∏è‚É£  Copie du script sur le WebServer..."
          if ! scp -o StrictHostKeyChecking=no \
            -o ConnectTimeout=30 \
            -i ~/.ssh/id_rsa \
            database/init.sql \
            ec2-user@$WEBSERVER_IP:/tmp/init.sql; then
            echo "‚ùå ERREUR: Impossible de copier le script sur le WebServer"
            exit 1
          fi
          echo "‚úÖ Script copi√© sur le WebServer"
          
          # Copier la cl√© SSH sur le WebServer pour qu'il puisse se connecter √† la Database
          echo "1.5Ô∏è‚É£  Configuration de la cl√© SSH sur le WebServer..."
          ssh -o StrictHostKeyChecking=no \
            -o ConnectTimeout=30 \
            -i ~/.ssh/id_rsa \
            ec2-user@$WEBSERVER_IP << 'SSH_SETUP'
            mkdir -p ~/.ssh
            chmod 700 ~/.ssh
          SSH_SETUP
          
          # Copier la cl√© SSH
          scp -o StrictHostKeyChecking=no \
            -o ConnectTimeout=30 \
            -i ~/.ssh/id_rsa \
            ~/.ssh/id_rsa \
            ec2-user@$WEBSERVER_IP:~/.ssh/id_rsa
          
          # Configurer les permissions de la cl√© sur le WebServer et ajouter la Database aux known_hosts
          ssh -o StrictHostKeyChecking=no \
            -o ConnectTimeout=30 \
            -i ~/.ssh/id_rsa \
            ec2-user@$WEBSERVER_IP \
            "chmod 600 ~/.ssh/id_rsa && ssh-keyscan -H $DATABASE_IP >> ~/.ssh/known_hosts 2>/dev/null || true && chmod 644 ~/.ssh/known_hosts"
          
          echo "‚úÖ Cl√© SSH configur√©e sur le WebServer"
          
          # Copier le script sur la DB via le WebServer
          echo "2Ô∏è‚É£  Copie du script sur la Database via le WebServer..."
          if ! ssh -o StrictHostKeyChecking=no \
            -o ConnectTimeout=30 \
            -i ~/.ssh/id_rsa \
            ec2-user@$WEBSERVER_IP \
            "scp -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa /tmp/init.sql ec2-user@$DATABASE_IP:/tmp/init.sql"; then
            echo "‚ùå ERREUR: Impossible de copier le script sur la Database"
            echo "V√©rifiez que:"
            echo "  1. Le Security Group de la Database autorise les connexions SSH depuis le WebServer"
            echo "  2. La cl√© SSH est correctement configur√©e sur le WebServer"
            exit 1
          fi
          echo "‚úÖ Script copi√© sur la Database"
          
          # Ex√©cuter le script sur la DB
          echo "3Ô∏è‚É£  Ex√©cution du script d'initialisation..."
          if ssh -o StrictHostKeyChecking=no \
            -o ConnectTimeout=30 \
            -i ~/.ssh/id_rsa \
            ec2-user@$WEBSERVER_IP \
            "ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa ec2-user@$DATABASE_IP \
            'sudo -u postgres psql -f /tmp/init.sql 2>&1 || echo \"Database may already be initialized\"'"; then
            echo "‚úÖ Base de donn√©es initialis√©e avec succ√®s"
          else
            echo "‚ö†Ô∏è  La base de donn√©es est peut-√™tre d√©j√† initialis√©e ou il y a eu une erreur"
            echo "V√©rifiez les logs ci-dessus pour plus de d√©tails"
          fi

  # ==================== JOB 5: Deploy Application ====================
  deploy-application:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, deploy-database]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # V√©rifier que le secret existe
          if [ -z "${{ secrets.EC2_SSH_PRIVATE_KEY }}" ]; then
            echo "‚ùå ERREUR: Le secret EC2_SSH_PRIVATE_KEY n'est pas configur√© dans GitHub"
            echo ""
            echo "üìã Pour configurer le secret:"
            echo "  1. Allez dans: Settings ‚Üí Secrets and variables ‚Üí Actions"
            echo "  2. Cliquez sur 'New repository secret'"
            echo "  3. Nom: EC2_SSH_PRIVATE_KEY"
            echo "  4. Valeur: Collez le contenu complet de votre cl√© priv√©e (.pem)"
            echo ""
            echo "üí° Utilisez le script local pour obtenir le contenu exact:"
            echo "  ./scripts/check-ssh-key.sh ~/.ssh/todo-app-key.pem"
            exit 1
          fi
          
          # √âcrire la cl√© SSH
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # V√©rifier le format de base
          if ! grep -q "BEGIN.*PRIVATE KEY" ~/.ssh/id_rsa; then
            echo "‚ùå ERREUR: La cl√© SSH ne contient pas l'en-t√™te BEGIN"
            echo ""
            echo "La cl√© doit commencer par:"
            echo "  -----BEGIN RSA PRIVATE KEY-----"
            echo "  ou"
            echo "  -----BEGIN OPENSSH PRIVATE KEY-----"
            echo ""
            echo "V√©rifiez que vous avez copi√© TOUTE la cl√©, y compris les en-t√™tes"
            exit 1
          fi
          
          if ! grep -q "END.*PRIVATE KEY" ~/.ssh/id_rsa; then
            echo "‚ùå ERREUR: La cl√© SSH ne contient pas l'en-t√™te END"
            echo ""
            echo "üîç Diagnostic:"
            KEY_SIZE=$(wc -c < ~/.ssh/id_rsa)
            KEY_LINES=$(wc -l < ~/.ssh/id_rsa)
            LAST_LINE=$(tail -1 ~/.ssh/id_rsa)
            echo "  Taille: $KEY_SIZE octets"
            echo "  Lignes: $KEY_LINES"
            echo "  Derni√®re ligne: '$LAST_LINE'"
            echo ""
            if [ $KEY_SIZE -lt 1500 ]; then
              echo "  ‚ö†Ô∏è  La cl√© est TROP COURTE! Elle est probablement TRONQU√âE."
              echo "  Une cl√© RSA priv√©e compl√®te fait g√©n√©ralement 1700-1800 octets."
            fi
            echo ""
            echo "üìã Cause probable:"
            echo "  La cl√© n'a pas √©t√© copi√©e compl√®tement dans GitHub Secrets."
            echo "  La fin de la cl√© (ligne -----END RSA PRIVATE KEY-----) est manquante."
            echo ""
            echo "üí° Solution:"
            echo "  1. Ex√©cutez localement: ./scripts/generate-ssh-secret.sh ~/.ssh/todo-app-key.pem"
            echo "  2. Ouvrez le fichier github-ssh-secret.txt g√©n√©r√©"
            echo "  3. V√©rifiez que la derni√®re ligne est: -----END RSA PRIVATE KEY-----"
            echo "  4. S√©lectionnez TOUT le contenu (Cmd+A) et copiez-le"
            echo "  5. Dans GitHub: Settings ‚Üí Secrets ‚Üí Actions ‚Üí EC2_SSH_PRIVATE_KEY"
            echo "  6. Supprimez l'ancien contenu et collez TOUT le nouveau contenu"
            echo "  7. Assurez-vous que la derni√®re ligne visible est -----END RSA PRIVATE KEY-----"
            echo ""
            echo "üìñ Guide complet: CONFIGURER_SSH_SECRET.md"
            exit 1
          fi
          
          # Afficher des informations de debug (sans exposer la cl√© compl√®te)
          echo "üîç Informations de debug:"
          KEY_SIZE=$(wc -c < ~/.ssh/id_rsa)
          KEY_LINES=$(wc -l < ~/.ssh/id_rsa)
          echo "  Taille du fichier: $KEY_SIZE octets"
          echo "  Nombre de lignes: $KEY_LINES"
          echo "  Premi√®re ligne: $(head -1 ~/.ssh/id_rsa)"
          echo "  Derni√®re ligne: $(tail -1 ~/.ssh/id_rsa)"
          echo ""
          
          # V√©rifier que la cl√© est valide avec ssh-keygen
          echo "üîç Validation de la cl√© SSH..."
          VALIDATION_OUTPUT=$(ssh-keygen -l -f ~/.ssh/id_rsa 2>&1)
          VALIDATION_EXIT=$?
          
          if [ $VALIDATION_EXIT -ne 0 ]; then
            echo "‚ùå ERREUR: La cl√© SSH n'est pas valide"
            echo ""
            echo "D√©tails de l'erreur:"
            echo "$VALIDATION_OUTPUT"
            echo ""
            echo "üìã Analyse du probl√®me:"
            if [ $KEY_SIZE -lt 1000 ]; then
              echo "  ‚ö†Ô∏è  La cl√© semble trop courte ($KEY_SIZE octets). Elle est probablement tronqu√©e."
            fi
            if [ $KEY_LINES -lt 10 ]; then
              echo "  ‚ö†Ô∏è  La cl√© a trop peu de lignes ($KEY_LINES). Les retours √† la ligne sont peut-√™tre perdus."
            fi
            if ! grep -q "BEGIN.*PRIVATE KEY" ~/.ssh/id_rsa; then
              echo "  ‚ö†Ô∏è  L'en-t√™te BEGIN est manquant"
            fi
            if ! grep -q "END.*PRIVATE KEY" ~/.ssh/id_rsa; then
              echo "  ‚ö†Ô∏è  L'en-t√™te END est manquant"
            fi
            echo ""
            echo "üìã V√©rifications √† faire:"
            echo "  1. La cl√© est au format PEM complet"
            echo "  2. Les en-t√™tes BEGIN et END sont pr√©sents"
            echo "  3. Tous les retours √† la ligne sont pr√©serv√©s"
            echo "  4. Aucun espace suppl√©mentaire n'a √©t√© ajout√©"
            echo "  5. La cl√© compl√®te a √©t√© copi√©e (pas tronqu√©e)"
            echo ""
            echo "üí° Solution:"
            echo "  1. Ex√©cutez localement: ./scripts/generate-ssh-secret.sh ~/.ssh/todo-app-key.pem"
            echo "  2. Ouvrez le fichier github-ssh-secret.txt g√©n√©r√©"
            echo "  3. Copiez TOUT le contenu dans GitHub Secrets (Settings ‚Üí Secrets ‚Üí Actions)"
            echo ""
            echo "üìñ Guide complet: CONFIGURER_SSH_SECRET.md"
            exit 1
          fi
          
          # Afficher le fingerprint de la cl√© (pour debug)
          echo "‚úÖ Cl√© SSH valide:"
          ssh-keygen -l -f ~/.ssh/id_rsa
          
          # Ajouter l'IP du WebServer aux known_hosts
          ssh-keyscan -H ${{ needs.deploy-infrastructure.outputs.webserver-ip }} >> ~/.ssh/known_hosts 2>/dev/null || true
          chmod 644 ~/.ssh/known_hosts

      - name: Get database IP
        id: get-db-ip
        run: |
          DATABASE_IP=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='DatabasePrivateIP'].OutputValue" \
            --output text)
          echo "database-ip=$DATABASE_IP" >> $GITHUB_OUTPUT

      - name: Deploy backend and frontend to EC2
        run: |
          WEBSERVER_IP="${{ needs.deploy-infrastructure.outputs.webserver-ip }}"
          
          # Cr√©er le fichier .env pour le backend
          echo "PORT=3000" > backend/.env
          echo "NODE_ENV=production" >> backend/.env
          echo "DB_HOST=${{ steps.get-db-ip.outputs.database-ip }}" >> backend/.env
          echo "DB_PORT=5432" >> backend/.env
          echo "DB_NAME=tododb" >> backend/.env
          echo "DB_USER=todouser" >> backend/.env
          echo "DB_PASSWORD=${{ secrets.DB_PASSWORD }}" >> backend/.env
          
          # Configurer l'URL de l'API dans le frontend build
          if [ -d "frontend/build" ]; then
            echo "üîß Configuration de l'URL de l'API dans le frontend..."
            # Mettre √† jour config.js avec la vraie IP
            sed -i "s|PLACEHOLDER_WEBSERVER_IP|$WEBSERVER_IP|g" frontend/build/config.js
            # Mettre √† jour index.html avec la vraie IP dans le script inline si pr√©sent
            sed -i "s|PLACEHOLDER_WEBSERVER_IP|$WEBSERVER_IP|g" frontend/build/index.html
            echo "‚úÖ Frontend configur√© avec l'URL API: http://$WEBSERVER_IP:3000"
          fi
          
          # Cr√©er une archive avec backend + frontend build
          # Structure: backend/ dans app/, frontend/build/ dans ../frontend/build/
          mkdir -p deploy-temp/backend
          cp -r backend/* deploy-temp/backend/
          mkdir -p deploy-temp/frontend
          cp -r frontend/build deploy-temp/frontend/
          cd deploy-temp
          tar -czf ../backend.tar.gz backend frontend
          cd ..
          rm -rf deploy-temp
          
          # Copier l'archive sur le serveur
          scp -o StrictHostKeyChecking=no \
            -o ConnectTimeout=30 \
            -i ~/.ssh/id_rsa \
            backend.tar.gz \
            ec2-user@${{ needs.deploy-infrastructure.outputs.webserver-ip }}:/tmp/
          
          # Extraire et d√©ployer
          ssh -o StrictHostKeyChecking=no \
            -o ConnectTimeout=30 \
            -i ~/.ssh/id_rsa \
            ec2-user@${{ needs.deploy-infrastructure.outputs.webserver-ip }} << 'EOF'
            mkdir -p /home/ec2-user/app
            cd /tmp
            tar -xzf backend.tar.gz
            rm backend.tar.gz
            
            # D√©placer le backend dans /home/ec2-user/app
            cp -r backend/* /home/ec2-user/app/
            
            # D√©placer le frontend build au bon endroit (relatif √† /home/ec2-user/app)
            if [ -d "frontend/build" ]; then
              echo "üì¶ D√©placement du frontend build..."
              mkdir -p /home/ec2-user/frontend
              mv frontend/build /home/ec2-user/frontend/
              echo "‚úÖ Frontend d√©ploy√© dans /home/ec2-user/frontend/build/"
              ls -la /home/ec2-user/frontend/build/ | head -5
            else
              echo "‚ö†Ô∏è  Frontend build non trouv√© dans l'archive"
            fi
            
            cd /home/ec2-user/app
            
            # Installer Node.js avec NVM (plus fiable sur Amazon Linux 2)
            if ! command -v node &> /dev/null; then
              echo "üì¶ Installation de NVM et Node.js 16..."
              curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
              export NVM_DIR="$HOME/.nvm"
              [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
              nvm install 16
              nvm use 16
              nvm alias default 16
              # Ajouter NVM au PATH pour les sessions futures
              echo 'export NVM_DIR="$HOME/.nvm"' >> ~/.bashrc
              echo '[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"' >> ~/.bashrc
              echo '[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"' >> ~/.bash_profile
            else
              # Si Node.js est d√©j√† install√©, s'assurer que NVM est charg√©
              export NVM_DIR="$HOME/.nvm"
              [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh" || true
            fi
            
            # S'assurer que Node.js et npm sont dans le PATH
            export NVM_DIR="$HOME/.nvm"
            [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
            node --version
            npm --version
            
            # Installer les d√©pendances
            npm install --production --no-audit
          
            # Arr√™ter l'ancienne instance
            pkill -f "node server.js" || true
            sleep 2
            
            # Charger NVM et d√©marrer l'application
            export NVM_DIR="$HOME/.nvm"
            [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
            
            # V√©rifier que Node.js est disponible
            if ! command -v node &> /dev/null; then
              echo "‚ùå ERREUR: Node.js n'est pas disponible"
              echo "Installation de NVM..."
              curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
              export NVM_DIR="$HOME/.nvm"
              [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
              nvm install 16
              nvm use 16
            fi
            
            echo "Node.js version: $(node --version)"
            echo "npm version: $(npm --version)"
            
            # V√©rifier que le fichier .env existe
            if [ ! -f .env ]; then
              echo "‚ùå ERREUR: Fichier .env non trouv√©"
              exit 1
            fi
            
            # D√©marrer l'application avec NVM charg√©
            echo "üöÄ D√©marrage de l'application..."
            cd /home/ec2-user/app
            export NVM_DIR="$HOME/.nvm"
            [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
            nohup bash -c 'source ~/.nvm/nvm.sh && node server.js' > app.log 2>&1 &
            APP_PID=$!
            sleep 5
            
            # V√©rifier que le processus tourne
            if ps -p $APP_PID > /dev/null 2>&1 || pgrep -f "node server.js" > /dev/null; then
              echo "‚úÖ Application d√©marr√©e (PID: $APP_PID)"
              echo "Port en √©coute:"
              sudo netstat -tlnp | grep :3000 || echo "Port 3000 pas encore en √©coute (peut prendre quelques secondes)"
              echo ""
              echo "Derni√®res lignes des logs:"
              tail -10 app.log
            else
              echo "‚ùå Erreur: L'application n'a pas d√©marr√©"
              echo "Logs complets:"
              cat app.log
              exit 1
            fi
          EOF

      - name: Deploy frontend (optional)
        run: |
          echo "Frontend build ready in frontend/build/"
          # Optionnel: d√©ployer sur S3 ou servir via nginx

  # ==================== JOB 6: Health Check ====================
  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    needs: deploy-application
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get WebServer IP from stack
        id: get-webserver-ip
        run: |
          WEBSERVER_IP=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query "Stacks[0].Outputs[?OutputKey=='WebServerPublicIP'].OutputValue" \
            --output text)
          
          if [ -z "$WEBSERVER_IP" ] || [ "$WEBSERVER_IP" == "None" ]; then
            echo "‚ùå ERREUR: Impossible de r√©cup√©rer l'IP du WebServer depuis la stack"
            exit 1
          fi
          
          echo "webserver-ip=$WEBSERVER_IP" >> $GITHUB_OUTPUT
          echo "üåê WebServer IP: $WEBSERVER_IP"

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          WEBSERVER_IP="${{ steps.get-webserver-ip.outputs.webserver-ip }}"
          ssh-keyscan -H $WEBSERVER_IP >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Wait for application to start
        run: |
          echo "‚è≥ Attente du d√©marrage de l'application..."
          sleep 30
          
          WEBSERVER_IP="${{ steps.get-webserver-ip.outputs.webserver-ip }}"
          MAX_ATTEMPTS=24
          ATTEMPT=0
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            # V√©rifier d'abord si l'application tourne sur le serveur
            if [ $ATTEMPT -eq 0 ] || [ $((ATTEMPT % 6)) -eq 0 ]; then
              echo "üîç Diagnostic du serveur (tentative $((ATTEMPT + 1)))..."
              ssh -o StrictHostKeyChecking=no \
                -o ConnectTimeout=10 \
                -i ~/.ssh/id_rsa \
                ec2-user@$WEBSERVER_IP \
                "echo '=== √âtat du processus Node.js ===' && \
                 ps aux | grep -E 'node|npm' | grep -v grep || echo 'Aucun processus Node.js trouv√©' && \
                 echo '' && \
                 echo '=== Port 3000 en √©coute ===' && \
                 sudo netstat -tlnp | grep :3000 || echo 'Port 3000 n'\''est pas en √©coute' && \
                 echo '' && \
                 echo '=== Derni√®res lignes des logs ===' && \
                 tail -20 /home/ec2-user/app/app.log 2>/dev/null || echo 'Fichier de log non trouv√©' && \
                 echo '' && \
                 echo '=== Variables d'\''environnement ===' && \
                 cat /home/ec2-user/app/.env 2>/dev/null || echo 'Fichier .env non trouv√©'" || true
            fi
            
            # Tester la connexion HTTP (accepter m√™me si la DB n'est pas connect√©e)
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -m 5 http://$WEBSERVER_IP:3000/health 2>/dev/null || echo "000")
            HEALTH_RESPONSE=$(curl -s -m 5 http://$WEBSERVER_IP:3000/health 2>/dev/null || echo "")
            
            # L'API r√©pond si on obtient un code HTTP ou une r√©ponse JSON
            if [ "$HTTP_CODE" != "000" ] && [ -n "$HEALTH_RESPONSE" ]; then
              echo "‚úÖ API est disponible (HTTP $HTTP_CODE)"
              
              # V√©rifier si c'est un probl√®me de DB uniquement
              if echo "$HEALTH_RESPONSE" | grep -q '"status":"ERROR"' || echo "$HEALTH_RESPONSE" | grep -q '"connected":false'; then
                echo "‚ö†Ô∏è  Note: La base de donn√©es n'est pas connect√©e, mais l'API r√©pond correctement"
                echo "   L'API fonctionne, le probl√®me de DB peut √™tre corrig√© s√©par√©ment"
              fi
              break
            fi
            
            ATTEMPT=$((ATTEMPT + 1))
            echo "‚è≥ Tentative $ATTEMPT/$MAX_ATTEMPTS..."
            sleep 5
          done
          
          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "‚ùå L'API n'est pas disponible apr√®s $MAX_ATTEMPTS tentatives"
            echo ""
            echo "üîç Diagnostic final..."
            ssh -o StrictHostKeyChecking=no \
              -o ConnectTimeout=10 \
              -i ~/.ssh/id_rsa \
              ec2-user@$WEBSERVER_IP \
              "echo '=== √âtat complet du serveur ===' && \
               echo 'Processus Node.js:' && \
               ps aux | grep -E 'node|npm' | grep -v grep || echo 'Aucun' && \
               echo '' && \
               echo 'Ports en √©coute:' && \
               sudo netstat -tlnp | grep -E ':3000|:22' || echo 'Aucun port pertinent' && \
               echo '' && \
               echo 'Logs complets de l'\''application:' && \
               cat /home/ec2-user/app/app.log 2>/dev/null || echo 'Logs non disponibles' && \
               echo '' && \
               echo 'Test local de l'\''API:' && \
               curl -s http://localhost:3000/health || echo 'API non accessible localement'" || true
            echo ""
            echo "üí° V√©rifications √† faire:"
            echo "  1. V√©rifiez que le Security Group autorise les connexions HTTP (port 3000) depuis 0.0.0.0/0"
            echo "  2. V√©rifiez les logs ci-dessus pour voir les erreurs de l'application"
            echo "  3. V√©rifiez que la base de donn√©es est accessible depuis le WebServer"
            exit 1
          fi

      - name: Check API health
        run: |
          WEBSERVER_IP="${{ steps.get-webserver-ip.outputs.webserver-ip }}"
          
          echo "üîç V√©rification de l'API..."
          
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" -m 10 http://$WEBSERVER_IP:3000/health)
          HEALTH_BODY=$(curl -s -m 10 http://$WEBSERVER_IP:3000/health || echo "")
          
          if [ "$RESPONSE" -eq 200 ]; then
            echo "‚úÖ API est en bonne sant√© (HTTP $RESPONSE)"
            echo "$HEALTH_BODY" | jq . || echo "$HEALTH_BODY"
          elif [ "$RESPONSE" -eq "000" ]; then
            echo "‚ùå API n'est pas accessible (timeout ou connexion refus√©e)"
            exit 1
          else
            echo "‚ö†Ô∏è  API r√©pond mais avec un code HTTP $RESPONSE"
            echo "R√©ponse:"
            echo "$HEALTH_BODY" | jq . || echo "$HEALTH_BODY"
            
            # V√©rifier si c'est juste un probl√®me de base de donn√©es
            if echo "$HEALTH_BODY" | grep -q "database.*connected.*false"; then
              echo ""
              echo "‚ö†Ô∏è  La base de donn√©es n'est pas connect√©e, mais l'API r√©pond"
              echo "üí° V√©rifiez que:"
              echo "  1. PostgreSQL est d√©marr√© sur l'instance Database"
              echo "  2. Le Security Group de la Database autorise les connexions depuis le WebServer (port 5432)"
              echo "  3. La base de donn√©es a √©t√© initialis√©e correctement"
              echo ""
              echo "‚úÖ Le d√©ploiement de l'API est r√©ussi, mais la connexion DB doit √™tre corrig√©e"
            else
              echo "‚ùå Probl√®me inconnu avec l'API"
            exit 1
            fi
          fi

      - name: Test API endpoints
        run: |
          WEBSERVER_IP="${{ steps.get-webserver-ip.outputs.webserver-ip }}"
          
          echo "üìã Test GET /api/todos..."
          curl -s -m 10 http://$WEBSERVER_IP:3000/api/todos | jq . || echo "Todos endpoint test completed"
          
          echo "üìä Test GET /api/todos/stats..."
          curl -s -m 10 http://$WEBSERVER_IP:3000/api/todos/stats || echo "Stats endpoint test completed"

  # ==================== JOB 7: Notification ====================
  notify:
    name: Send Notification
    runs-on: ubuntu-latest
    needs: health-check
    if: always()

    steps:
      - name: Send success notification
        if: needs.health-check.result == 'success'
        run: |
          echo "‚úÖ D√©ploiement r√©ussi!"
          echo "üåê Application accessible sur: http://${{ needs.deploy-infrastructure.outputs.webserver-ip }}:3000"

      - name: Send failure notification
        if: needs.health-check.result == 'failure'
        run: |
          echo "‚ùå D√©ploiement √©chou√©!"
          exit 1