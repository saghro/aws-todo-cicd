name: CI/CD Pipeline - Deploy Todo App to AWS

on:
  push:
    branches:
      - main
      - develop
  pull_request:
    branches:
      - main

env:
  AWS_REGION: us-east-1
  STACK_NAME: todo-app-stack

jobs:
  # ==================== JOB 1: Tests ====================
  test:
    name: Run Tests
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json

      - name: Install backend dependencies
        working-directory: ./backend
        run: npm ci

      - name: Run backend tests
        working-directory: ./backend
        run: npm test || echo "No tests found"
        continue-on-error: true

      - name: Lint backend code
        working-directory: ./backend
        run: npm run lint || echo "No lint configured"
        continue-on-error: true

  # ==================== JOB 2: Build ====================
  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: test

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Build backend
        working-directory: ./backend
        run: |
          npm ci
          echo "Backend built successfully"

      - name: Build frontend
        working-directory: ./frontend
        run: |
          npm ci
          npm run build

      - name: Archive artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: |
            backend/
            frontend/build/
          retention-days: 1

  # ==================== JOB 3: Infrastructure ====================
  deploy-infrastructure:
    name: Deploy AWS Infrastructure
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    outputs:
      webserver-ip: ${{ steps.get-outputs.outputs.webserver-ip }}
      database-ip: ${{ steps.get-outputs.outputs.database-ip }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify Key Pair exists
        run: |
          echo "üîç V√©rification de la Key Pair EC2..."
          KEY_PAIR_NAME="${{ secrets.EC2_KEY_PAIR_NAME }}"
          
          if aws ec2 describe-key-pairs --key-names "$KEY_PAIR_NAME" --region ${{ env.AWS_REGION }} &> /dev/null; then
            echo "‚úÖ Key Pair '$KEY_PAIR_NAME' existe dans la r√©gion ${{ env.AWS_REGION }}"
            
            # Afficher le fingerprint
            FINGERPRINT=$(aws ec2 describe-key-pairs \
              --key-names "$KEY_PAIR_NAME" \
              --region ${{ env.AWS_REGION }} \
              --query "KeyPairs[0].KeyFingerprint" \
              --output text)
            echo "üìã Fingerprint: $FINGERPRINT"
          else
            echo "‚ùå ERREUR: Key Pair '$KEY_PAIR_NAME' n'existe pas dans la r√©gion ${{ env.AWS_REGION }}"
            echo ""
            echo "üîß Solutions:"
            echo "  1. Cr√©ez la Key Pair dans la console AWS:"
            echo "     https://${{ env.AWS_REGION }}.console.aws.amazon.com/ec2/home?region=${{ env.AWS_REGION }}#KeyPairs:"
            echo ""
            echo "  2. Ou cr√©ez-la via AWS CLI:"
            echo "     aws ec2 create-key-pair --key-name $KEY_PAIR_NAME --region ${{ env.AWS_REGION }}"
            echo ""
            echo "  3. Assurez-vous que le secret EC2_KEY_PAIR_NAME dans GitHub correspond au nom exact"
            exit 1
          fi

      - name: Validate CloudFormation template
        run: |
          aws cloudformation validate-template \
            --template-body file://infrastructure/infrastructure.yml

      - name: Deploy CloudFormation stack
        run: |
          echo "üöÄ D√©ploiement de la stack CloudFormation..."
          echo "Stack: ${{ env.STACK_NAME }}"
          echo "R√©gion: ${{ env.AWS_REGION }}"
          echo "Key Pair: ${{ secrets.EC2_KEY_PAIR_NAME }}"
          echo ""
          
          # V√©rifier que la Key Pair existe AVANT le d√©ploiement
          echo "üîç V√©rification finale de la Key Pair..."
          KEY_PAIR_NAME="${{ secrets.EC2_KEY_PAIR_NAME }}"
          
          # Afficher la longueur et les caract√®res (pour d√©boguer)
          echo "Longueur du nom: ${#KEY_PAIR_NAME}"
          echo "Nom (avec guillemets pour voir les espaces): '$KEY_PAIR_NAME'"
          echo ""
          
          # Lister toutes les Key Pairs disponibles
          echo "üìã Key Pairs disponibles dans ${{ env.AWS_REGION }}:"
          aws ec2 describe-key-pairs --region ${{ env.AWS_REGION }} --query "KeyPairs[*].KeyName" --output table
          echo ""
          
          # V√©rifier si la Key Pair existe
          if ! aws ec2 describe-key-pairs --key-names "$KEY_PAIR_NAME" --region ${{ env.AWS_REGION }} &> /dev/null; then
            echo "‚ùå ERREUR CRITIQUE: Key Pair '$KEY_PAIR_NAME' n'existe pas dans ${{ env.AWS_REGION }}"
            echo ""
            echo "üí° Solution: Utilisez une des Key Pairs list√©es ci-dessus"
            echo "   Modifiez le secret EC2_KEY_PAIR_NAME dans GitHub avec exactement le nom de la Key Pair"
            exit 1
          fi
          
          # Afficher les d√©tails de la Key Pair trouv√©e
          KEY_INFO=$(aws ec2 describe-key-pairs --key-names "$KEY_PAIR_NAME" --region ${{ env.AWS_REGION }} --query "KeyPairs[0]" --output json)
          echo "‚úÖ Key Pair v√©rifi√©e: $KEY_PAIR_NAME"
          echo "   Fingerprint: $(echo "$KEY_INFO" | jq -r '.KeyFingerprint')"
          echo "   Type: $(echo "$KEY_INFO" | jq -r '.KeyType')"
          echo ""
          
          # Tenter le d√©ploiement avec create-stack d'abord (pour voir l'erreur compl√®te)
          echo "üîç V√©rification si la stack existe..."
          STACK_STATUS=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query "Stacks[0].StackStatus" \
            --output text 2>/dev/null || echo "NOT_FOUND")
          
          # Si la stack est en cours de cr√©ation ou de mise √† jour, attendre
          if [ "$STACK_STATUS" == "CREATE_IN_PROGRESS" ] || [ "$STACK_STATUS" == "UPDATE_IN_PROGRESS" ] || [ "$STACK_STATUS" == "UPDATE_ROLLBACK_IN_PROGRESS" ]; then
            echo "‚è≥ Stack en cours de traitement ($STACK_STATUS), attente de la fin..."
            if [ "$STACK_STATUS" == "CREATE_IN_PROGRESS" ]; then
              echo "‚è≥ Attente de la fin de la cr√©ation (cela peut prendre 10-15 minutes)..."
              aws cloudformation wait stack-create-complete \
                --stack-name ${{ env.STACK_NAME }} \
                --region ${{ env.AWS_REGION }} || true
            elif [ "$STACK_STATUS" == "UPDATE_IN_PROGRESS" ]; then
              echo "‚è≥ Attente de la fin de la mise √† jour..."
              aws cloudformation wait stack-update-complete \
                --stack-name ${{ env.STACK_NAME }} \
                --region ${{ env.AWS_REGION }} || true
            fi
            # Re-v√©rifier le statut apr√®s l'attente
            STACK_STATUS=$(aws cloudformation describe-stacks \
              --stack-name ${{ env.STACK_NAME }} \
              --region ${{ env.AWS_REGION }} \
              --query "Stacks[0].StackStatus" \
              --output text 2>/dev/null || echo "NOT_FOUND")
            echo "üìä Statut apr√®s attente: $STACK_STATUS"
            echo ""
          fi
          
          if [ "$STACK_STATUS" == "NOT_FOUND" ]; then
            echo "üì¶ Cr√©ation de la stack (premi√®re fois)..."
            # Utiliser create-stack pour voir l'erreur compl√®te
            if ! aws cloudformation create-stack \
              --stack-name ${{ env.STACK_NAME }} \
              --template-body file://infrastructure/infrastructure.yml \
              --parameters \
                ParameterKey=EnvironmentName,ParameterValue=prod \
                ParameterKey=KeyPairName,ParameterValue="$KEY_PAIR_NAME" \
                ParameterKey=AlertEmail,ParameterValue=${{ secrets.ALERT_EMAIL }} \
              --capabilities CAPABILITY_IAM \
              --region ${{ env.AWS_REGION }}; then
              
              echo ""
              echo "‚ùå √âchec de la cr√©ation de la stack"
              echo "R√©cup√©ration des d√©tails de l'erreur..."
              # Attendre un peu pour que l'erreur soit enregistr√©e
              sleep 5
              
              # Obtenir les √©v√©nements r√©cents
              aws cloudformation describe-stack-events \
                --stack-name ${{ env.STACK_NAME }} \
                --region ${{ env.AWS_REGION }} \
                --max-items 5 \
                --query "StackEvents[*].[Timestamp,ResourceStatus,LogicalResourceId,ResourceStatusReason]" \
                --output table 2>/dev/null || echo "Stack pas encore cr√©√©e"
              
              exit 1
            fi
            echo "‚úÖ Stack en cours de cr√©ation..."
            echo "‚è≥ Attente de la cr√©ation (cela peut prendre 10-15 minutes)..."
            
            # Attendre avec gestion d'erreur
            if ! aws cloudformation wait stack-create-complete \
              --stack-name ${{ env.STACK_NAME }} \
              --region ${{ env.AWS_REGION }}; then
              
              echo ""
              echo "‚ùå √âchec de la cr√©ation de la stack"
              echo "===================================="
              echo ""
              
              # Obtenir l'√©tat final
              FINAL_STATUS=$(aws cloudformation describe-stacks \
                --stack-name ${{ env.STACK_NAME }} \
                --region ${{ env.AWS_REGION }} \
                --query "Stacks[0].StackStatus" \
                --output text 2>/dev/null || echo "UNKNOWN")
              
              echo "√âtat final: $FINAL_STATUS"
              echo ""
              
              # Afficher les √©v√©nements d'erreur
              echo "üìã √âv√©nements d'erreur de la stack (CREATE_FAILED):"
              FAILED_EVENTS=$(aws cloudformation describe-stack-events \
                --stack-name ${{ env.STACK_NAME }} \
                --region ${{ env.AWS_REGION }} \
                --max-items 50 \
                --query "StackEvents[?ResourceStatus=='CREATE_FAILED'].[Timestamp,LogicalResourceId,ResourceStatusReason]" \
                --output table 2>/dev/null || echo "")
              
              if [ -n "$FAILED_EVENTS" ]; then
                echo "$FAILED_EVENTS"
              else
                echo "Aucun √©v√©nement CREATE_FAILED trouv√©"
                echo ""
                echo "Recherche de tous les √©v√©nements avec 'failed' ou 'error'..."
                aws cloudformation describe-stack-events \
                  --stack-name ${{ env.STACK_NAME }} \
                  --region ${{ env.AWS_REGION }} \
                  --max-items 50 \
                  --query "StackEvents[?contains(ResourceStatusReason, 'failed') || contains(ResourceStatusReason, 'Failed') || contains(ResourceStatusReason, 'error') || contains(ResourceStatusReason, 'Error') || contains(ResourceStatusReason, 'already exists')].[Timestamp,LogicalResourceId,ResourceStatus,ResourceStatusReason]" \
                  --output table 2>/dev/null || echo "Impossible de r√©cup√©rer les √©v√©nements"
              fi
              
              echo ""
              echo "üìã Tous les √©v√©nements r√©cents:"
              aws cloudformation describe-stack-events \
                --stack-name ${{ env.STACK_NAME }} \
                --region ${{ env.AWS_REGION }} \
                --max-items 15 \
                --query "StackEvents[*].[Timestamp,ResourceStatus,LogicalResourceId,ResourceStatusReason]" \
                --output table || echo "Impossible de r√©cup√©rer les √©v√©nements"
              
              exit 1
            fi
            
            echo "‚úÖ Stack cr√©√©e avec succ√®s"
          elif [ "$STACK_STATUS" != "NOT_FOUND" ]; then
            echo "üîÑ Mise √† jour de la stack existante..."
            echo "üìä Statut actuel: $STACK_STATUS"
            # Utiliser deploy pour la mise √† jour
            if ! aws cloudformation deploy \
              --template-file infrastructure/infrastructure.yml \
              --stack-name ${{ env.STACK_NAME }} \
              --parameter-overrides \
                EnvironmentName=prod \
                KeyPairName="$KEY_PAIR_NAME" \
                AlertEmail=${{ secrets.ALERT_EMAIL }} \
              --capabilities CAPABILITY_IAM \
              --no-fail-on-empty-changeset \
              --region ${{ env.AWS_REGION }}; then
              
              echo ""
              echo "‚ùå √âchec de la mise √† jour de la stack"
              echo "R√©cup√©ration des d√©tails..."
              sleep 3
              
              echo ""
              echo "‚ùå √âchec du d√©ploiement CloudFormation"
              echo "======================================"
              echo ""
              
              # Afficher les √©v√©nements r√©cents
              echo "üìã √âv√©nements r√©cents de la stack:"
              aws cloudformation describe-stack-events \
                --stack-name ${{ env.STACK_NAME }} \
                --region ${{ env.AWS_REGION }} \
                --max-items 5 \
                --query "StackEvents[*].[Timestamp,ResourceStatus,LogicalResourceId,ResourceStatusReason]" \
                --output table || echo "Impossible de r√©cup√©rer les √©v√©nements"
              
              echo ""
              echo "üîç Recherche de changementsets en √©chec..."
              CHANGESET_ID=$(aws cloudformation list-change-sets \
                --stack-name ${{ env.STACK_NAME }} \
                --region ${{ env.AWS_REGION }} \
                --query "Summaries[?Status=='FAILED'] | [0].ChangeSetId" \
                --output text 2>/dev/null || echo "")
              
              if [ -n "$CHANGESET_ID" ] && [ "$CHANGESET_ID" != "None" ]; then
                echo "üìã Raison de l'√©chec du changeset:"
                aws cloudformation describe-change-set \
                  --change-set-name "$CHANGESET_ID" \
                  --stack-name ${{ env.STACK_NAME }} \
                  --region ${{ env.AWS_REGION }} \
                  --query "StatusReason" \
                  --output text || echo "Impossible de r√©cup√©rer la raison"
              fi
              
              echo ""
              echo "üí° V√©rifications √† faire:"
              echo "  1. V√©rifiez que la Key Pair '$KEY_PAIR_NAME' existe dans ${{ env.AWS_REGION }}"
              echo "  2. V√©rifiez les permissions IAM de votre utilisateur AWS"
              echo "  3. V√©rifiez que l'AMI ID dans le template existe dans ${{ env.AWS_REGION }}"
              echo ""
              echo "üìã Key Pairs disponibles dans ${{ env.AWS_REGION }}:"
              aws ec2 describe-key-pairs --region ${{ env.AWS_REGION }} --query "KeyPairs[*].KeyName" --output table || echo "Impossible de lister les Key Pairs"
              
              exit 1
            fi
            echo "‚úÖ Stack mise √† jour avec succ√®s"
          fi
          
          echo "‚úÖ Stack d√©ploy√©e avec succ√®s"

      - name: Get stack outputs
        id: get-outputs
        run: |
          WEBSERVER_IP=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='WebServerPublicIP'].OutputValue" \
            --output text)
          
          DATABASE_IP=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='DatabasePrivateIP'].OutputValue" \
            --output text)
          
          echo "webserver-ip=$WEBSERVER_IP" >> $GITHUB_OUTPUT
          echo "database-ip=$DATABASE_IP" >> $GITHUB_OUTPUT
          
          echo "üåê WebServer IP: $WEBSERVER_IP"
          echo "üíæ Database IP: $DATABASE_IP"

  # ==================== JOB 4: Deploy Database ====================
  deploy-database:
    name: Deploy Database
    runs-on: ubuntu-latest
    needs: deploy-infrastructure
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # V√©rifier que le secret existe
          if [ -z "${{ secrets.EC2_SSH_PRIVATE_KEY }}" ]; then
            echo "‚ùå ERREUR: Le secret EC2_SSH_PRIVATE_KEY n'est pas configur√© dans GitHub"
            echo ""
            echo "üìã Pour configurer le secret:"
            echo "  1. Allez dans: Settings ‚Üí Secrets and variables ‚Üí Actions"
            echo "  2. Cliquez sur 'New repository secret'"
            echo "  3. Nom: EC2_SSH_PRIVATE_KEY"
            echo "  4. Valeur: Collez le contenu complet de votre cl√© priv√©e (.pem)"
            echo ""
            echo "üí° Utilisez le script local pour obtenir le contenu exact:"
            echo "  ./scripts/check-ssh-key.sh ~/.ssh/todo-app-key.pem"
            exit 1
          fi
          
          # √âcrire la cl√© SSH
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # V√©rifier le format de base
          if ! grep -q "BEGIN.*PRIVATE KEY" ~/.ssh/id_rsa; then
            echo "‚ùå ERREUR: La cl√© SSH ne contient pas l'en-t√™te BEGIN"
            echo ""
            echo "La cl√© doit commencer par:"
            echo "  -----BEGIN RSA PRIVATE KEY-----"
            echo "  ou"
            echo "  -----BEGIN OPENSSH PRIVATE KEY-----"
            echo ""
            echo "V√©rifiez que vous avez copi√© TOUTE la cl√©, y compris les en-t√™tes"
            exit 1
          fi
          
          if ! grep -q "END.*PRIVATE KEY" ~/.ssh/id_rsa; then
            echo "‚ùå ERREUR: La cl√© SSH ne contient pas l'en-t√™te END"
            echo ""
            echo "La cl√© doit se terminer par:"
            echo "  -----END RSA PRIVATE KEY-----"
            echo "  ou"
            echo "  -----END OPENSSH PRIVATE KEY-----"
            exit 1
          fi
          
          # V√©rifier que la cl√© est valide avec ssh-keygen
          echo "üîç Validation de la cl√© SSH..."
          VALIDATION_OUTPUT=$(ssh-keygen -l -f ~/.ssh/id_rsa 2>&1)
          VALIDATION_EXIT=$?
          
          if [ $VALIDATION_EXIT -ne 0 ]; then
            echo "‚ùå ERREUR: La cl√© SSH n'est pas valide"
            echo ""
            echo "D√©tails de l'erreur:"
            echo "$VALIDATION_OUTPUT"
            echo ""
            echo "üìã V√©rifications √† faire:"
            echo "  1. La cl√© est au format PEM complet"
            echo "  2. Les en-t√™tes BEGIN et END sont pr√©sents"
            echo "  3. Tous les retours √† la ligne sont pr√©serv√©s"
            echo "  4. Aucun espace suppl√©mentaire n'a √©t√© ajout√©"
            echo ""
            echo "üí° Pour obtenir le contenu exact de votre cl√©:"
            echo "  Ex√©cutez localement: ./scripts/check-ssh-key.sh ~/.ssh/todo-app-key.pem"
            echo "  Puis copiez-collez TOUT le contenu affich√© dans GitHub Secrets"
            exit 1
          fi
          
          # Afficher le fingerprint de la cl√© (pour debug)
          echo "‚úÖ Cl√© SSH valide:"
          ssh-keygen -l -f ~/.ssh/id_rsa
          
          # Ajouter l'IP du WebServer aux known_hosts
          ssh-keyscan -H ${{ needs.deploy-infrastructure.outputs.webserver-ip }} >> ~/.ssh/known_hosts 2>/dev/null || true
          chmod 644 ~/.ssh/known_hosts

      - name: Get database IP from stack
        id: get-db-ip
        run: |
          DATABASE_IP=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='DatabasePrivateIP'].OutputValue" \
            --output text)
          echo "database-ip=$DATABASE_IP" >> $GITHUB_OUTPUT

      - name: Wait for instances to be ready
        run: |
          echo "‚è≥ Attente de la disponibilit√© des instances..."
          WEBSERVER_IP="${{ needs.deploy-infrastructure.outputs.webserver-ip }}"
          MAX_ATTEMPTS=30
          ATTEMPT=0
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            echo "Tentative $((ATTEMPT + 1))/$MAX_ATTEMPTS: Test de connexion SSH..."
            if ssh -o StrictHostKeyChecking=no \
               -o ConnectTimeout=10 \
               -o BatchMode=yes \
               -i ~/.ssh/id_rsa \
               ec2-user@$WEBSERVER_IP \
               "echo 'SSH connection successful'" &> /dev/null; then
              echo "‚úÖ Instance WebServer est pr√™te!"
              break
            fi
            ATTEMPT=$((ATTEMPT + 1))
            if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
              echo "‚è≥ Instance pas encore pr√™te, attente de 10 secondes..."
              sleep 10
            fi
          done
          
          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "‚ùå ERREUR: Impossible de se connecter au WebServer apr√®s $MAX_ATTEMPTS tentatives"
            echo "V√©rifiez que:"
            echo "  1. L'instance est en cours d'ex√©cution"
            echo "  2. Le Security Group autorise les connexions SSH depuis GitHub Actions"
            echo "  3. La cl√© SSH est correctement configur√©e"
            exit 1
          fi

      - name: Deploy database initialization script
        run: |
          WEBSERVER_IP="${{ needs.deploy-infrastructure.outputs.webserver-ip }}"
          DATABASE_IP="${{ steps.get-db-ip.outputs.database-ip }}"
          
          echo "üì¶ D√©ploiement du script d'initialisation de la base de donn√©es..."
          echo "WebServer IP: $WEBSERVER_IP"
          echo "Database IP: $DATABASE_IP"
          
          # Copier le script sur le WebServer
          echo "1Ô∏è‚É£  Copie du script sur le WebServer..."
          if ! scp -o StrictHostKeyChecking=no \
            -o ConnectTimeout=30 \
            -i ~/.ssh/id_rsa \
            database/init.sql \
            ec2-user@$WEBSERVER_IP:/tmp/init.sql; then
            echo "‚ùå ERREUR: Impossible de copier le script sur le WebServer"
            exit 1
          fi
          echo "‚úÖ Script copi√© sur le WebServer"
          
          # Copier le script sur la DB via le WebServer
          echo "2Ô∏è‚É£  Copie du script sur la Database via le WebServer..."
          if ! ssh -o StrictHostKeyChecking=no \
            -o ConnectTimeout=30 \
            -i ~/.ssh/id_rsa \
            ec2-user@$WEBSERVER_IP \
            "scp -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa /tmp/init.sql ec2-user@$DATABASE_IP:/tmp/init.sql"; then
            echo "‚ùå ERREUR: Impossible de copier le script sur la Database"
            echo "V√©rifiez que le WebServer peut se connecter √† la Database via SSH"
            exit 1
          fi
          echo "‚úÖ Script copi√© sur la Database"
          
          # Ex√©cuter le script sur la DB
          echo "3Ô∏è‚É£  Ex√©cution du script d'initialisation..."
          if ssh -o StrictHostKeyChecking=no \
            -o ConnectTimeout=30 \
            -i ~/.ssh/id_rsa \
            ec2-user@$WEBSERVER_IP \
            "ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa ec2-user@$DATABASE_IP \
            'sudo -u postgres psql -f /tmp/init.sql 2>&1 || echo \"Database may already be initialized\"'"; then
            echo "‚úÖ Base de donn√©es initialis√©e avec succ√®s"
          else
            echo "‚ö†Ô∏è  La base de donn√©es est peut-√™tre d√©j√† initialis√©e ou il y a eu une erreur"
            echo "V√©rifiez les logs ci-dessus pour plus de d√©tails"
          fi

  # ==================== JOB 5: Deploy Application ====================
  deploy-application:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, deploy-database]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # V√©rifier que le secret existe
          if [ -z "${{ secrets.EC2_SSH_PRIVATE_KEY }}" ]; then
            echo "‚ùå ERREUR: Le secret EC2_SSH_PRIVATE_KEY n'est pas configur√© dans GitHub"
            echo ""
            echo "üìã Pour configurer le secret:"
            echo "  1. Allez dans: Settings ‚Üí Secrets and variables ‚Üí Actions"
            echo "  2. Cliquez sur 'New repository secret'"
            echo "  3. Nom: EC2_SSH_PRIVATE_KEY"
            echo "  4. Valeur: Collez le contenu complet de votre cl√© priv√©e (.pem)"
            echo ""
            echo "üí° Utilisez le script local pour obtenir le contenu exact:"
            echo "  ./scripts/check-ssh-key.sh ~/.ssh/todo-app-key.pem"
            exit 1
          fi
          
          # √âcrire la cl√© SSH
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # V√©rifier le format de base
          if ! grep -q "BEGIN.*PRIVATE KEY" ~/.ssh/id_rsa; then
            echo "‚ùå ERREUR: La cl√© SSH ne contient pas l'en-t√™te BEGIN"
            echo ""
            echo "La cl√© doit commencer par:"
            echo "  -----BEGIN RSA PRIVATE KEY-----"
            echo "  ou"
            echo "  -----BEGIN OPENSSH PRIVATE KEY-----"
            echo ""
            echo "V√©rifiez que vous avez copi√© TOUTE la cl√©, y compris les en-t√™tes"
            exit 1
          fi
          
          if ! grep -q "END.*PRIVATE KEY" ~/.ssh/id_rsa; then
            echo "‚ùå ERREUR: La cl√© SSH ne contient pas l'en-t√™te END"
            echo ""
            echo "La cl√© doit se terminer par:"
            echo "  -----END RSA PRIVATE KEY-----"
            echo "  ou"
            echo "  -----END OPENSSH PRIVATE KEY-----"
            exit 1
          fi
          
          # V√©rifier que la cl√© est valide avec ssh-keygen
          echo "üîç Validation de la cl√© SSH..."
          VALIDATION_OUTPUT=$(ssh-keygen -l -f ~/.ssh/id_rsa 2>&1)
          VALIDATION_EXIT=$?
          
          if [ $VALIDATION_EXIT -ne 0 ]; then
            echo "‚ùå ERREUR: La cl√© SSH n'est pas valide"
            echo ""
            echo "D√©tails de l'erreur:"
            echo "$VALIDATION_OUTPUT"
            echo ""
            echo "üìã V√©rifications √† faire:"
            echo "  1. La cl√© est au format PEM complet"
            echo "  2. Les en-t√™tes BEGIN et END sont pr√©sents"
            echo "  3. Tous les retours √† la ligne sont pr√©serv√©s"
            echo "  4. Aucun espace suppl√©mentaire n'a √©t√© ajout√©"
            echo ""
            echo "üí° Pour obtenir le contenu exact de votre cl√©:"
            echo "  Ex√©cutez localement: ./scripts/check-ssh-key.sh ~/.ssh/todo-app-key.pem"
            echo "  Puis copiez-collez TOUT le contenu affich√© dans GitHub Secrets"
            exit 1
          fi
          
          # Afficher le fingerprint de la cl√© (pour debug)
          echo "‚úÖ Cl√© SSH valide:"
          ssh-keygen -l -f ~/.ssh/id_rsa
          
          # Ajouter l'IP du WebServer aux known_hosts
          ssh-keyscan -H ${{ needs.deploy-infrastructure.outputs.webserver-ip }} >> ~/.ssh/known_hosts 2>/dev/null || true
          chmod 644 ~/.ssh/known_hosts

      - name: Get database IP
        id: get-db-ip
        run: |
          DATABASE_IP=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='DatabasePrivateIP'].OutputValue" \
            --output text)
          echo "database-ip=$DATABASE_IP" >> $GITHUB_OUTPUT

      - name: Deploy backend to EC2
        run: |
          # Cr√©er le fichier .env
          echo "PORT=3000" > backend/.env
          echo "NODE_ENV=production" >> backend/.env
          echo "DB_HOST=${{ steps.get-db-ip.outputs.database-ip }}" >> backend/.env
          echo "DB_PORT=5432" >> backend/.env
          echo "DB_NAME=tododb" >> backend/.env
          echo "DB_USER=todouser" >> backend/.env
          echo "DB_PASSWORD=${{ secrets.DB_PASSWORD }}" >> backend/.env
          
          # Cr√©er une archive
          tar -czf backend.tar.gz -C backend .
          
          # Copier l'archive sur le serveur
          scp -o StrictHostKeyChecking=no \
            -o ConnectTimeout=30 \
            -i ~/.ssh/id_rsa \
            backend.tar.gz \
            ec2-user@${{ needs.deploy-infrastructure.outputs.webserver-ip }}:/tmp/
          
          # Extraire et d√©ployer
          ssh -o StrictHostKeyChecking=no \
            -o ConnectTimeout=30 \
            -i ~/.ssh/id_rsa \
            ec2-user@${{ needs.deploy-infrastructure.outputs.webserver-ip }} << 'EOF'
            mkdir -p /home/ec2-user/app
            cd /home/ec2-user/app
            tar -xzf /tmp/backend.tar.gz
            rm /tmp/backend.tar.gz
            
            # Installer Node.js si n√©cessaire
            if ! command -v node &> /dev/null; then
              curl -fsSL https://rpm.nodesource.com/setup_16.x | sudo bash -
              sudo yum install -y nodejs
            fi
            
            # Installer les d√©pendances
            npm install --production --no-audit
            
            # Arr√™ter l'ancienne instance
            pkill -f "node server.js" || true
            sleep 2
            
            # D√©marrer la nouvelle instance
            nohup node server.js > /home/ec2-user/app/app.log 2>&1 &
            sleep 5
            
            # V√©rifier que le processus tourne
            if pgrep -f "node server.js" > /dev/null; then
              echo "‚úÖ Application d√©ploy√©e avec succ√®s"
            else
              echo "‚ùå Erreur: L'application n'a pas d√©marr√©"
              cat /home/ec2-user/app/app.log
              exit 1
            fi
          EOF

      - name: Deploy frontend (optional)
        run: |
          echo "Frontend build ready in frontend/build/"
          # Optionnel: d√©ployer sur S3 ou servir via nginx

  # ==================== JOB 6: Health Check ====================
  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    needs: deploy-application
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
      - name: Wait for application to start
        run: |
          echo "‚è≥ Attente du d√©marrage de l'application..."
          sleep 45
          
          # Attendre jusqu'√† 2 minutes que l'API r√©ponde
          WEBSERVER_IP="${{ needs.deploy-infrastructure.outputs.webserver-ip }}"
          MAX_ATTEMPTS=24
          ATTEMPT=0
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            if curl -s -f -m 5 http://$WEBSERVER_IP:3000/health > /dev/null 2>&1; then
              echo "‚úÖ API est disponible"
              break
            fi
            ATTEMPT=$((ATTEMPT + 1))
            echo "‚è≥ Tentative $ATTEMPT/$MAX_ATTEMPTS..."
            sleep 5
          done
          
          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "‚ùå L'API n'est pas disponible apr√®s $MAX_ATTEMPTS tentatives"
            exit 1
          fi

      - name: Check API health
        run: |
          WEBSERVER_IP="${{ needs.deploy-infrastructure.outputs.webserver-ip }}"
          
          echo "üîç V√©rification de l'API..."
          
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" -m 10 http://$WEBSERVER_IP:3000/health)
          
          if [ "$RESPONSE" -eq 200 ]; then
            echo "‚úÖ API est en bonne sant√© (HTTP $RESPONSE)"
            curl -s -m 10 http://$WEBSERVER_IP:3000/health | jq . || echo "Health check response received"
          else
            echo "‚ùå API ne r√©pond pas correctement (HTTP $RESPONSE)"
            exit 1
          fi

      - name: Test API endpoints
        run: |
          WEBSERVER_IP="${{ needs.deploy-infrastructure.outputs.webserver-ip }}"
          
          echo "üìã Test GET /api/todos..."
          curl -s -m 10 http://$WEBSERVER_IP:3000/api/todos | jq . || echo "Todos endpoint test completed"
          
          echo "üìä Test GET /api/todos/stats..."
          curl -s -m 10 http://$WEBSERVER_IP:3000/api/todos/stats || echo "Stats endpoint test completed"

  # ==================== JOB 7: Notification ====================
  notify:
    name: Send Notification
    runs-on: ubuntu-latest
    needs: health-check
    if: always()

    steps:
      - name: Send success notification
        if: needs.health-check.result == 'success'
        run: |
          echo "‚úÖ D√©ploiement r√©ussi!"
          echo "üåê Application accessible sur: http://${{ needs.deploy-infrastructure.outputs.webserver-ip }}:3000"

      - name: Send failure notification
        if: needs.health-check.result == 'failure'
        run: |
          echo "‚ùå D√©ploiement √©chou√©!"
          exit 1